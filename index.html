// A) Pipe lines
for (const line of lines){
  if (!line.includes("|")) continue;
  const parts = line.split(/\s*\|\s*/).map(s=>s.trim());

  const dateRaw = parts[0] || "";
  const isDateLine = /^\d{2}[./]\d{2}[./](\d{2}|\d{4})$/.test(dateRaw);

  const desc = parts[2] ?? "";
  const qtyCell = parts[3] ?? "";
  const debitCell = parts[4] ?? "";
  const creditCell = parts[5] ?? "";

  // ✅ Fortsetzungszeile: kein Datum, aber Description ist "19 X 94.00" oder "-1 X 97.50"
  const descClean = String(desc || "").replace(/\s+/g," ").trim();
  const contMatch = (!isDateLine && /^-?\d+\s*[xX]\s*-?\d+(?:[.,]\d+)?$/.test(descClean))
    ? descClean.match(/^(-?\d+)\s*[xX]\s*(-?\d+(?:[.,]\d+)?)$/)
    : null;

  // --- 1) Fortsetzungszeile behandeln: an vorherige Position anhängen
  if (contMatch){
    const prev = items[items.length - 1];
    if (prev){
      const q = toNumber(contMatch[1]);        // kann -1 sein
      const u = toNumber(contMatch[2]);

      // a) an Beschreibung anhängen (für Export/Print sichtbar)
      prev.desc = (prev.desc ? prev.desc + "\n" : "") + `${contMatch[1]} X ${contMatch[2]}`;

      // b) qty/unit füllen, wenn noch leer (oder 0/blank)
      if (prev.qty === "" || prev.qty === 0 || prev.qty === null || prev.qty === undefined){
        prev.qty = q;
      }
      if (prev.unit === "" || prev.unit === 0 || prev.unit === null || prev.unit === undefined){
        prev.unit = u;
      }
      // nichts neues pushen
      continue;
    }
    // falls keine vorherige Zeile vorhanden -> ignorieren
    continue;
  }

  // --- 2) Normale Zeile: Datum ist Pflicht
  if (!isDateLine) continue;

  const date = normDate(dateRaw);

  const qty = (/^\d{1,6}$/.test(qtyCell) ? toNumber(qtyCell) : "");

  let debitVal = debitCell ? parseMoneyCell(debitCell) : "";
  let creditVal = creditCell ? parseMoneyCell(creditCell) : "";

  // Falls Debit negativ ist und es keine Credit-Spalte gab:
  // - bei (Accommodation/Manual/CityTax) bleibt negativ im Debit
  // - sonst wird es zu Credit (positiv)
  if (debitVal !== "" && debitVal < 0 && (creditVal === "" || creditVal === 0)){
    if (!keepNegativeInDebit(desc)){
      creditVal = Math.abs(debitVal);
      debitVal = "";
    }
  }

  const item = {
    date,
    desc,
    qty: qty === "" ? "" : qty,
    unit: "",
    debit: (debitVal === "" ? "" : debitVal),
    credit: (creditVal === "" ? "" : Math.abs(creditVal)),
    vatRate: defaultRate,
    vatEnabled: true
  };

  // ✅ MwSt-Regel bleibt gleich
  if (shouldDisableVatByRule(item)){
    item.vatEnabled = false;
    item.vatRate = 0;
  }

  items.push(item);
}
